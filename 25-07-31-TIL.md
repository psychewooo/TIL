### 25-07-31

#### 오늘의 시행착오

1. is 연산자
```python

class UserInfo:
    def __init__(self):
        self.user_data = {}

    def get_user_info(self):

        name = input('이름을 입력하세요: ')

        if name == '':
            return None
               
        try:
            age_input = input('나이를 입력하세요: ')
            age = int(age_input)

            self.user_data = {'이름': name, '나이': age}
            return True

        except ValueError:
             print('나이는 숫자로 입력해야 합니다.')
             return False

    def display_user_info(self):

        if self.user_data:
            print('사용자 정보:')
            for key in self.user_data:
                print(f'{key}: {self.user_data[key]}')

        else:
            print('사용자 정보가 입력되지 않았습니다.')

user = UserInfo()
result = user.get_user_info()

if result is True:
    user.display_user_info()
elif result is None:
    user.display_user_info()

```
<br>
위 문제에서 아래와 같이 작성할 경우 '사용자 정보가 입력되지 않았습니다'가 출력됨  

<br>

```python

        if self.user_data is True:

```
<br>
이는 is 연산자의 사용으로 인해 발생한 문제  

<br>

* **is (Identity Operator)**  
  * 두 변수가 완전히 동일한 메모리 주소의 객체를 가리키는지, 즉 정체성이 같은지를 확인
  * 주로 싱글턴 객체를 비교할 때 사용

<br>

self.user_data는 딕셔너리, True는 불린이기에 같은 메모리 주소를 가질 수 없음

<br>

**문제 A**
```python
class Dog():
    
    def bark(self):
        print("멍멍!")

class Cat():

    def meow(self):
        print("야옹!")

class Pet(Dog, Cat):
    
    def __init__(self, sound):
        super().__init__()
        self.sound = sound
    
    def play(self):
        print("애완동물과 놀기")
    
    def make_sound(self):
        print(self.sound)


pet1 = Pet("그르르")
pet1.make_sound()
pet1.bark()
pet1.meow()
pet1.play()
```
**문제 B**
```python

class Dog():
    # Dog 클래스는 동물의 소리를 sound 클래스 속성으로 가진다
    sound = '멍멍'

class Cat():
    # Cat 클래스는 동물의 소리를 sound 클래스 속성으로 가진다
    sound = '야옹'


# Pet 클래스는 Dog 클래스와 Cat 클래스를 다중 상속 받아야 한다
# Case 1. Dog Class 우선 상속

class Pet(Dog, Cat):
    def __init__(self):
        super().__init__()

    def __str__(self):
        return f'애완동물은 {self.sound} 소리를 냅니다.'

pet1 = Pet()
print(pet1)


# Case 2. Cat Class 우선 상속

class Pet(Cat, Dog):
    def __init__(self):
        super().__init__()

    def __str__(self):
        return f'애완동물은 {self.sound} 소리를 냅니다.'

pet2 = Pet()
print(pet2)

```


문제 A의 경우 self.sound를 Pet.sound로 작성시 오류 발생
```python
class Pet(Dog, Cat):
    
    def __init__(self, sound):
        super().__init__()
        self.sound = sound
    
    def play(self):
        print("애완동물과 놀기")
    
    def make_sound(self):
        print(Pet.sound)
```
